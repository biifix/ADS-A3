%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>
endobj
4 0 obj
<< /Length 2920 >>
stream
BT
/F1 10 Tf
1 0 0 1 72 780 Tm
0 -14 Td (Results explanation \(using figures\)) Tj
0 -14 Td () Tj
0 -14 Td (Time results) Tj
0 -14 Td (- The performance plots \(performance_metric1.png, performance_metric2.png, performance_metric3.png; algo1_performance.png, algo2_performance.png, algo3_performance.png; performance_analysis.png\) show three distinct growth patterns. Algorithm 1?s points rise steeply and break off on harder instances, indicating explosive growth and frequent failure to complete. Algorithm 2 scales across all puzzles with steadily increasing nodes/time as instance difficulty grows. Algorithm 3?s curves are much flatter, solving all puzzles with far fewer node expansions.) Tj
0 -14 Td (- Representative stats \(see ANALYSIS.txt and time_memory_analysis.png\):) Tj
0 -14 Td (  ? Algo1: avg 284,566 generated / 52,493 expanded; solved 11/16.) Tj
0 -14 Td (  ? Algo2: avg 708,516 generated / 653,439 expanded; solved 16/16; impassable3 ~10.3M expanded \(~1011 s\).) Tj
0 -14 Td (  ? Algo3: avg 12,167 generated / 11,917 expanded; solved 16/16; impassable3 ~155K expanded \(~68.8 s\).) Tj
0 -14 Td () Tj
0 -14 Td (Space results) Tj
0 -14 Td (- The space plots \(space_algorithm_1.png, space_algorithm_2.png, space_algorithm_3.png, space_comparative.png\) show Algorithm 1?s frontier blowing up when it succeeds, Algorithm 2?s memory dominated by the visited?set \(radix tree\), and Algorithm 3 using a much smaller working set.) Tj
0 -14 Td (- Illustrative numbers \(ANALYSIS.txt\): impassable3 ? Algo2 ~358 MB auxiliary + large queue; Algo3 ~5 MB total \(no persistent aux structures\).) Tj
0 -14 Td () Tj
0 -14 Td (Q1. Which time complexity growth does the data show, and does it match theory?) Tj
0 -14 Td (- Algorithm 1: Data shows exponential?like growth in time; fails on harder puzzles. Matches theory.) Tj
0 -14 Td (- Algorithm 2: Data scales roughly linearly with the number of unique states; completes all puzzles. Matches theory.) Tj
0 -14 Td (- Algorithm 3: Data shows markedly reduced growth \(solutions found at small widths\), far below exploring the full space. Matches the theoretical expectation of strong pruning via width bounds.) Tj
0 -14 Td () Tj
0 -14 Td (Q2. What?s the memory \(space\) growth of Algorithms 2 and 3, and do they decrease the growth rate vs Algorithm 1?) Tj
0 -14 Td (- Algorithm 2: Memory grows with the count of unique states because it stores a visited?set \(radix tree\). This reduces growth rate compared to Algorithm 1?s exploding frontier; empirically much lower than Algo1?s would be on hard puzzles, though it can still be large \(e.g., ~358 MB on impassable3\).) Tj
0 -14 Td (- Algorithm 3: Memory is bounded by the current width?s working set and freed between iterations, yielding substantially smaller space needs than both Algorithm 1 and 2. This further decreases the growth rate versus Algorithm 1 and also versus Algorithm 2 in practice.) Tj
ET
endstream
endobj
5 0 obj
<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>
endobj
xref
0 6
0000000000 65535 f 
0000000009 00000 n 
0000000058 00000 n 
0000000115 00000 n 
0000000241 00000 n 
0000003213 00000 n 
trailer
<< /Size 6 /Root 1 0 R >>
startxref
3283
%%EOF
